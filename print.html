<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kobold</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="webhooks/index.html"><strong aria-hidden="true">2.</strong> Webhooks Events</a></li><li class="chapter-item expanded "><a href="comments/index.html"><strong aria-hidden="true">3.</strong> Comments</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="comments/exact.html"><strong aria-hidden="true">3.1.</strong> Exact Match</a></li><li class="chapter-item expanded "><a href="comments/semver.html"><strong aria-hidden="true">3.2.</strong> Semantic Versioning</a></li><li class="chapter-item expanded "><a href="comments/regex.html"><strong aria-hidden="true">3.3.</strong> Regular Expression</a></li></ol></li><li class="chapter-item expanded "><a href="image-tags/index.html"><strong aria-hidden="true">4.</strong> Image Tags</a></li><li class="chapter-item expanded "><a href="configuration/index.html"><strong aria-hidden="true">5.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="configuration/endpoints.html"><strong aria-hidden="true">5.1.</strong> Endpoints</a></li><li class="chapter-item expanded "><a href="configuration/repositories.html"><strong aria-hidden="true">5.2.</strong> Repositories</a></li><li class="chapter-item expanded "><a href="configuration/subscriptions.html"><strong aria-hidden="true">5.3.</strong> Subscriptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="configuration/pull-requests.html"><strong aria-hidden="true">5.3.1.</strong> Pull Requests</a></li><li class="chapter-item expanded "><a href="configuration/scopes.html"><strong aria-hidden="true">5.3.2.</strong> Scopes</a></li><li class="chapter-item expanded "><a href="configuration/file-associations.html"><strong aria-hidden="true">5.3.3.</strong> File Associations</a></li></ol></li><li class="chapter-item expanded "><a href="configuration/resolvers.html"><strong aria-hidden="true">5.4.</strong> Resolvers</a></li><li class="chapter-item expanded "><a href="configuration/registry-auth.html"><strong aria-hidden="true">5.5.</strong> Registry Auth</a></li></ol></li><li class="chapter-item expanded "><a href="deployment/index.html"><strong aria-hidden="true">6.</strong> Deployment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deployment/kubernetes.html"><strong aria-hidden="true">6.1.</strong> Kubernetes</a></li><li class="chapter-item expanded "><a href="deployment/bare-metal.html"><strong aria-hidden="true">6.2.</strong> Bare Metal</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kobold</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/bluebrown/kobold" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><img src="./arch.svg" alt="architecture" /></p>
<p>Kobold is a gitbot that reacts to webhook events, typically emitted by container
registries. When it receives an event, it searches one or more configured
repositories for yaml files for image nodes containing a special inline comment.</p>
<p>The presence of this comment signals to kobold that it should act on this image
reference. It then determines if the given image tag should be updated. After it
is done <em>walking</em> the repository, it will commit and push the change and
optionally make open a pull request.</p>
<p>It can walk the same repository multiple times with different scopes, i.e. on
/env/dev it should make a direct commit but on /env/prod it should open a pull
request instead.</p>
<p>This provides an agnostic way of updating image references in git repositories.
Typically other tools would take over from here, for example argocd could detect
the changes made by kobold and sync them into the kubernetes cluster.</p>
<p>However, kobold is not bound to any specific tool. It is not even bound to
kubernetes resources. It cant detect image references in other yaml files as
well. For example docker-compose files.</p>
<p>One could even use it to keep a service in sync across multiple application
repositories. Imagine, you build a microservice and it is used for integration
tests in a number of other repositories. Kobold could ensure they stay in sync.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webhooks-events"><a class="header" href="#webhooks-events">Webhooks Events</a></h1>
<p>Kobold listens for webhooks event using the
<a href="webhooks/../configuration/endpoints.html">endpoint</a> configurations from the config.yaml.
The webhook endpoints can have different types such as dockerhub or ACR. This is
because webhooks events from the various registries send different payloads.</p>
<p>Since kobold requires the digest to work, some registries require kobold to
fetch the digest upon receiving the event because its not part of the payload.
If such a registry is used, kobold requires to be able to
<a href="webhooks/../configuration/registry-auth.html">authenticate</a> against the registry.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>Once a webhook event is received, kobold performs a search in any
<a href="comments/../configuration/repositories.html">repository</a> that is
<a href="comments/../configuration/subscriptions.html">subscribed</a> to the origin
<a href="comments/../configuration/endpoints.html">endpoint</a>. It looks for image nodes containing
an inline comment with some options to configure the behavior on case by case
basis.</p>
<p>Inline comments keep the logic lean and avoid verbosity while preserving valid
yaml.</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: my-app
    image: org/app # kobold: tag: ^1; type: semver
</code></pre>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>The comments parsed by kobold have the following format:</p>
<pre><code class="language-console"># kobold: tag: &lt;tag-name&gt;; type: &lt;tag-type&gt;
</code></pre>
<p>The tag-type can be either <a href="comments/./exact.html">exact</a>, <a href="comments/./semver.html">semver</a>, or
<a href="comments/regex.html">regex</a>, and specifies how kobold should interpret the tag-name.</p>
<p>For example, if tag-type is semver, the tag-name can include common semantic
versioning semantics, such as ^1 to denote that any tag between v1 and v2 should
be matched (not including v2).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exact-match"><a class="header" href="#exact-match">Exact Match</a></h1>
<p>When using the type <code>exact</code> as comment option. The tag from the webhook event
must match exactly the tag in the comment option.</p>
<pre><code class="language-yaml">image: bluebrown/busybox # kobold: tag: latest; type: exact
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semantic-versioning"><a class="header" href="#semantic-versioning">Semantic Versioning</a></h1>
<p>It is best practice to use semantic versioning. With the type <code>semver</code>, you can
match image tags that adhere to the semver spec.</p>
<pre><code class="language-yaml">image: bluebrown/busybox # kobold: tag: ^1; type: semver
</code></pre>
<p>The incoming tag is matched with the tag in the comment option using
<a href="https://github.com/Masterminds/semver">Masterminds semver</a>. You can review the
<a href="https://github.com/Masterminds/semver#basic-comparisons">comparison rules</a> in
their readme to learn more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regular-expression"><a class="header" href="#regular-expression">Regular Expression</a></h1>
<p>If you don't want to use exact matches and your team is not doing semver yet,
you can use the <code>regex</code> type to match any pattern.</p>
<pre><code class="language-yaml">image: bluebrown/busybox # kobold: tag: sprint_\d+; type: regex
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-tags"><a class="header" href="#image-tags">Image Tags</a></h1>
<p>By default, the image tags in the git repository are updated with the digest of
the container image, rather than just the tag.</p>
<p>The digest is a unique identifier that is generated based on the contents of the
image, so even if the tag remains the same, the digest will change if the
contents of the image are updated. This allows kobold to stay up to date with
the correct image, even if the same tag is pushed multiple times.</p>
<p>The behavior can be configured using the <code>--imageref-template</code> flag. The default
value is the below.</p>
<pre><code class="language-console">{{ .Image }}:{{ .Tag }}@{{ .Digest }}
</code></pre>
<p>This string must be a valid go-template. The data passed into this template is
the <a href="image-tags/./internal/events/events.go"><code>PushEvent</code></a>.</p>
<p>Note that that when using the default form, the tag is only there for
informational purposes. This is because most registries will <a href="https://github.com/distribution/distribution/blob/362910506bc213e9bfc3e3e8999e0cfc757d34ba/reference/normalize.go#L88">ignore the tag if
a digest is
present</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Kobold parses a config file in order to wire up the webhook server. The config
file is composed of various sections that can be pieced together. This allows
for flexibility while working with multiple registries, repositories and
branches.</p>
<p>Kobold will detected changes to the configuration file and perform a graceful
reload, without interrupting currently running processes.</p>
<p>Environment variables in the config files are supported. They will be expected
according to linux conventions, meaning <code>$var</code> and <code>${var}</code> work.</p>
<p>Below is an example with all possible configurations. Many properties are
options. You can grab the
<a href="https://github.com/bluebrown/kobold/blob/main/hack/schema.json">json-schema</a>,
to learn more.</p>
<pre><code class="language-yaml">version: v1
commitMessage:
  title: &quot;chore(kobold): update images&quot;
  description: |
    {{- range . }}
    - change {{ .Source }}[{{ .Parent }}]:
      - old: {{ .OldImageRef }}
      - new: {{ .NewImageRef }}
      - opt: {{ .OptionsExpression }}
    {{- end }}
registryAuth:
  namespace: ${NAMESPACE}
  serviceAccount: kobold
  imagePullSecrets:
    - name: regcreds
endpoints:
  - name: dockerhub
    type: dockerhub
    path: /dockerhub
    requiredHeaders: []
repositories:
  - name: kobold
    url: https://github.com/bluebrown/kobold
    username: &quot;${GIT_USR}&quot;
    password: &quot;${GIT_PAT}&quot;
    provider: github
subscriptions:
  - name: example
    endpointRefs:
      - name: dockerhub
    repositoryRef:
      name: kobold
    branch: main
    strategy: pull-request
    scopes:
      - env/dev/
      - env/stage/
    fileAssociations:
      - kind: ko-build
        pattern: &quot;.ko.yaml&quot;
      - kind: docker-compose
        pattern: &quot;*compose*.y?ml&quot;
      - kind: kubernetes
        pattern: &quot;*&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="endpoints"><a class="header" href="#endpoints">Endpoints</a></h1>
<p>The endpoints section of the config file specifies the webhook endpoints that
Kobold should listen to. These can be of different types, such as Azure
Container Registry or Docker Hub.</p>
<p>Each endpoint must have a unique name, a type, a path and a optional list of
requiredHeaders. The path is the URL path that the endpoint listens to, and the
requiredHeaders are HTTP headers that must be included in the webhook request
for it to be accepted by Kobold.</p>
<pre><code class="language-yaml">endpoints:
  - name: myacr
    type: acr
    path: /acr/292d91a8-d073-4a65-99b8-0018fa6f8f46
   requiredHeaders:
      - key: Authorization
        value: &quot;Basic ${BASE64AUTH}&quot;
</code></pre>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>Currently supported endpoint types are <code>acr</code>, <code>dockerhub</code>, <code>distribution</code> and <code>generic</code>.
The generic type expects the image reference in plain text. It can be used if you
want to dispatch events manually, perhaps via pipeline.</p>
<blockquote>
<p><strong>Note</strong> If there is no type for your registry of choice, please open an issue
so that we can add it to the codebase.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repositories"><a class="header" href="#repositories">Repositories</a></h1>
<p>The repositories section of the config file specifies the git repositories that
Kobold should update when it receives a webhook event. The presence of a
repository does not lead to any actual updates when an event is received. The
repository functions as abstract type that can be referenced by subscriptions.</p>
<pre><code class="language-yaml">repositories:
- name: kobold
    url: https://github.com/bluebrown/kobold
    username: &quot;${GIT_USR}&quot;
    password: &quot;${GIT_PAT}&quot;
    provider: github
</code></pre>
<p>At the moment, only password/token authentication is supported. This is because
for <a href="configuration/./pull-requests.html">pull-requests</a>, you need to use password authentication
regardless. So it is more easy to share the authentication config for regular
git commands and <a href="configuration/./pull-requests.html">pull-requests</a>.</p>
<blockquote>
<p><strong>Note</strong> that the provider is not required but may help if kobold is not able
to infer the provider based on the url.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subscriptions"><a class="header" href="#subscriptions">Subscriptions</a></h1>
<p>The subscriptions section of the config file specifies the rules that determine
which webhook events should trigger updates to which repositories. Each
subscription must have a name, a list of endpointRefs, a repositoryRef, a
branch, a strategy, and a list of scopes.</p>
<p>The <code>endpointRefs</code> are references to the <a href="configuration/./endpoints.html">endpoints</a> specified
in the endpoints section that should trigger this subscription.</p>
<p>The <code>repositoryRef</code> is a reference to the <a href="configuration/./repositories.html">repository</a>
specified in the repositories section that should be updated, the branch is the
branch of the repository to update.</p>
<p>The <code>strategy</code> is the update strategy and can be either commit or
<a href="configuration/./pull-requests.html">pull-request</a>.</p>
<p>The <a href="configuration/./scopes.html"><code>scopes</code></a> are the file or directory paths within the
repository to operate on. This allows to subscribe with a given repository
multiple times using different branches, scopes and strategies.</p>
<pre><code class="language-yaml">subscriptions:
  - name: example
    endpointRefs:
      - name: my-dockerhub
      - name: my-acr
    repositoryRef:
      name: kobold
    branch: main
    strategy: pull-request
    scopes:
      - env/prod/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h1>
<p>By default kobold will commit directly to the configured branch of the
subscription. However, it can be configured to open pull requests if it detects
changes to a given subscription.</p>
<pre><code class="language-yaml">subscriptions:
  - name: example
    strategy: pull-request
    branch: main
</code></pre>
<p>The branch name for the pull request will be <code>kobold/&lt;epoch-time&gt;</code> and the PR
will be made against branch in the subscription.</p>
<p>In order to use pull-requests, your git provider must be supported since git
itself has no concept of pull requests. Pull requests are made via rest api call
and hence provider specific.</p>
<p>Currently supported providers are <code>github</code> and <code>azure</code>.</p>
<p>The provider is inferred but can be configured via
<a href="configuration/./repositories.html">repository</a>.</p>
<blockquote>
<p><strong>Note</strong> If your provider is not available, please open an issue so that we
can add it to the codebase.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scopes"><a class="header" href="#scopes">Scopes</a></h1>
<p>Each subscription can be scoped to one or more path. The path in the scope list
are inverted gitignore rules. So the matching works the same as in a .gitignore.</p>
<pre><code class="language-yaml">subscriptions:
  - name: example
    scopes:
      - /env/prod/
      - /docker-compose.yaml
</code></pre>
<p>This is useful if you want to use different strategies within the same
repository. For example you could use the <code>commit</code> strategy for your staging
environment and <code>pull-request</code> for the production environment.</p>
<p>It could be used to rollout new application versions automatically to a staging
environment, for review by your stakeholders. Once they are happy, you can merge
the pull request for your production environment.</p>
<pre><code class="language-yaml">subscriptions:
  - name: stage
    strategy: commit
    scopes:
      - /env/stage/

  - name: prod
    strategy: pull-request
    scopes:
      - /env/prod/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-associations"><a class="header" href="#file-associations">File Associations</a></h1>
<p>The type of a given yaml file is determined by using glob to math the filename.
The default matching rules look like this:</p>
<pre><code class="language-yaml">- kind: ko-build
  pattern: &quot;.ko.yaml&quot;
- kind: docker-compose
  pattern: &quot;*compose*.y?ml&quot;
- kind: kubernetes
  pattern: &quot;*&quot;
</code></pre>
<p>In some cases it can be useful to overwrite the default rules. This can be done
per subscription.</p>
<pre><code class="language-yaml">subscriptions:
  - name: example
    fileAssociations:
      - kind: docker-compose
        pattern: &quot;dev.yaml&quot;
      - kind: kubernetes
        pattern: &quot;*&quot;
</code></pre>
<p>If the builtin resolvers are not sufficient. You can <a href="configuration/./resolvers.html">create your own
resolvers</a>, that you can reference in the <code>fileAssociations</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolvers"><a class="header" href="#resolvers">Resolvers</a></h1>
<p>It is possible to create custom resolvers, to look up image references in yaml
files.</p>
<pre><code class="language-yaml">resolvers:
  - name: my-custom
    paths:
      - path.to.image
      - another.path
</code></pre>
<p>If a resolvers is used, via a <a href="configuration/./file-associations.html">file association</a>, image
references at all paths of the resolver are handled. Kobold does not stop on
first match. Additionally, if a path does not exist, kobold will continue with
the next path, without error or warning.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registry-auth"><a class="header" href="#registry-auth">Registry Auth</a></h1>
<p>Depending on the image registry, the push event payload may not contain all
required data. In such cases, kobold will fetch the missing data from the given
registry. Because of this it may need to authenticate against the registry.</p>
<p>The <a href="https://github.com/google/go-containerregistry/tree/main/pkg/authn">authn
package</a> is
used for authentication. You can review their repository to learn more. It will
be either the default or k8s chain.</p>
<h2 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h2>
<p>When running in kubernetes, the registryAuth property can be used to access
image pull secrets. For this the <code>--k8schain</code> switch must be set.
ImagePullSecrets are taken from the service account in the configuration and
from imagePullSecrets listed. Both service account and imagePullSecrets are
looked up in the given namespace.</p>
<pre><code class="language-yaml">registryAuth:
  namespace: ${NAMESPACE}
  serviceAccount: kobold
  imagePullSecrets:
    - name: regcreds
</code></pre>
<p>When enabling the k8schain, you <em>may</em> need to create rbac resources allowing
kobold to lookup services accounts and secrets.</p>
<p>The below rbac resources config will be created if you use the provided
kustomization, to ensure kobold is allowed to lookup service accounts and
secrets in its own namespace.</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ServiceAccount
metadata:
  name: kobold
automountServiceAccountToken: true
imagePullSecrets: []
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: k8schain
rules:
  - apiGroups: [&quot;&quot;]
    resources: [&quot;serviceaccounts&quot;, &quot;secrets&quot;]
    verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: kobold-k8schain
  namespace: default
subjects:
  - kind: ServiceAccount
    name: kobold
    namespace: default
roleRef:
  kind: Role
  name: k8schain
  apiGroup: rbac.authorization.k8s.io
</code></pre>
<p>You can disable the lookup of the service account by using the value <code>no service account</code> as service account name.</p>
<pre><code class="language-yaml">registryAuth:
  serviceAccount: &quot;no service account&quot;
</code></pre>
<p>By doing this, you could remove the resource <code>serviceaccounts</code> from the rbac
role.</p>
<p>If you don't provide a <code>registryAuth</code> key in your config and use the k8s chain,
kobold will default to the values of the environment variables <code>$NAMESPACE</code> and
<code>$SERVICE_ACCOUNT_NAME</code>, if set. Otherwise it will use the <code>default</code> namespace and
<code>no service account</code>. This allows to use the other parts of the k8s chain
without the actual need for rbac.</p>
<h2 id="bare-metal"><a class="header" href="#bare-metal">Bare Metal</a></h2>
<p>If the flag is not used, kobold will attempt to use your local configuration to
authenticate. If you have logged in via docker cli, for example, kobold will be
able to access your private repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<p>The kobold binary accepts so optional flags. These can be used to influence the runtime behavior.</p>
<pre><code class="language-toml">Usage of kobold:
  -config string
        path to the config file (default &quot;path/to/kobold/config.yaml&quot;)
  -data string
        path to temporary data (default &quot;/tmp/kobold&quot;)
  -default-registry string
        the default registry to use, for unprefixed images (default &quot;index.docker.io&quot;)
  -imageref-template string
        the format of the image ref when updating an image node (default &quot;{{ .Image }}:{{ .Tag }}@{{ .Digest }}&quot;)
  -k8schain
        use k8schain for registry authentication
  -log-format string
        the log format, console or json (default &quot;json&quot;)
  -port int
        set the server port (default 8080)
  -v int
        verbosity level. 0 is fatal - 7 is trace (default 5)
  -version
        show version info
  -watch
        Reload the server on config file change
  -debounce duration
        debounce events until no event has been received for the provided duration (default 1m0s)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes-1"><a class="header" href="#kubernetes-1">Kubernetes</a></h1>
<p>You can use the provided kustomization as resource and overwrite the config and
env secret with your own.</p>
<pre><code class="language-yaml">apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: kobold
resources:
  - https://github.com/bluebrown/kobold//manifests/dist/?rev=main
  - ingress.yaml
configMapGenerator:
  - name: kobold-config
    behavior: replace
    files:
      - ./etc/config.yaml
secretGenerator:
  - name: kobold-env
    behavior: replace
    envs:
      - ./etc/.env
</code></pre>
<p>This will also create rbac rules and use the k8schain as shown in
<a href="deployment/../configuration/registry-auth.html">registry-auth</a>.</p>
<blockquote>
<p><strong>Note</strong> Your config file should contain at least the version. Currently only
<code>v1</code> exists.</p>
</blockquote>
<h2 id="ingress"><a class="header" href="#ingress">Ingress</a></h2>
<p>Since kobold listens for webhook event, you probably want to deploy an ingress.
It is recommended to use UUIDS for your path so that the path is not guessable.
This is especially important of your registry does not support custom headers.</p>
<pre><code class="language-yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kobold
  labels:
    app.kubernetes.io/name: kobold
spec:
  rules:
    - http:
        paths:
          - pathType: Exact
            path: &quot;/dockerhub/9a06938d-4022-46d3-8528-82cb95ee1ad5&quot;
            backend:
              service:
                name: kobold
                port:
                  name: http
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bare-metal-1"><a class="header" href="#bare-metal-1">Bare Metal</a></h1>
<p>You can run kobold via binary from the <a href="https://github.com/bluebrown/kobold/releases">release
page</a>.</p>
<h2 id="binary"><a class="header" href="#binary">Binary</a></h2>
<pre><code class="language-bash">./kobold
</code></pre>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>If you want to run kobold via docker, mount your config file to /ko-app/config.yaml
or use the <code>--config</code> flag.</p>
<pre><code class="language-bash">docker run -v &quot;$PWD/config.yaml:/ko-app/config.yaml&quot; -p 8080:8080 bluebrown/kobold
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
